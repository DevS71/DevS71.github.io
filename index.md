## Devin Schmidt's ePortfolio

An example of the projects that demonstrate the skills and abilitys I use in developing software.


#### Table of Contents
1.	[Professional Self-Assessment](#1-professional-self-assessment)
2.	[Code Review](#2-code-review)
3.	[Project 1: Software Design and Engineering](#3-project-1-software-design-and-engineering)
4.	[Project 2: Data Structures and Algorithms](#4-project-2-data-structures-and-algorithms)
5.	[Project 3: Databases](#5-project-3-databases)

### 1. Profesional Self-Assessment
Starting out in the Computer Science program I was unsure of what I wanted to do with my degree when I earned it. Through the experiences in the program, I learned that I enjoyed writing code. I liked to design solutions to solve problems, implement those solutions as code, and see the solution work. I even enjoyed the process of debugging, of hunting down and finding the reason the code won’t execute or work properly. Thus, I have decided to concentrate on software engineering, to pursue the design and development of software that solves problems.

In the pursuit of my degree, I learned several new skills, abilities, and techniques to use in the development of software. When I started, I didn’t know how to write a line of code. Now I know there is a lot of work that goes in before the first line is ever written. A problem must first be identified, then a solution can be designed that addresses the problem. 

The software then enters a cyclical design process. This process allows for quicker development of software that provides more value to the clients and users. The first step in this process is to gather information from the clients/users, what do they want to see in the product, and what functionality is needed. These are often described as user stories. Flow charts and diagrams can then be developed, or updated, to demonstrate the flow and functions of the envisioned software. The stories are then gathered into a backlog and a decision of which ones will be developed in this cycle is made. The decision on which stories to develop on the given cycle is determined by both the priority of the story and the amount of work the team agrees it can accomplish in a cycle to deliver functioning code. Armed with this information, the next step in the cycle can begin.

The next step is the start of the development process. This step in the process will involve using pseudocode to get a better view of the project, from a higher level. The pseudocode allows for several different questions to be solved before code is ever written. Pseudocode can identify the variables that will be needed, where code will be repeated and thus a method or function can be made. It allows for the exploration of different options in code design, without writing any code. The Pseudocode also provides a map, allowing the developers to segment the code into different classes. Once all this information has been compiled, code can start to be produced.

The code is the heart of the software, and all the work prior to its production ensures the code produces software that meets the needs of stakeholders in the most efficient form possible. As the code is developed, care should be takin to ensure the maintainability and upgradability of the code. Using comments in the code will ensure that in the future the use of the code and the logic behind it is known. This is not the end of the process though as the code should be verified that it is stable and secure. 

The next step in the cycle is the testing. The code should be tested with multiple inputs of both expected and unexpected data types. The inputs should be varied, with values that are within the acceptable limits and values that are outside the limits. These values should represent both edge cases and values from within the middle of the range. At this stage the code should also undergo a security audit, to verify that it is securing data and that any dependencies don’t introduce vulnerabilities.

Finally, the code should be released to the users or a select group of users. This allows the users to run the code and played with by the people using it. They can then identify features they don’t use, don’t need or what they see is missing. Using the information gathered from this step of the process the next cycle can be informed. This will guide what the next features, or stories, need attention and allows the team to know they are heading in the right direction. The feedback from the users allows for the development to be dynamic and deliver value to the customer.

I’ve learned the use of this process produces code that solves a problem and meets the needs of the stakeholders. It creates efficient code in a timely manner that is easily updated and maintained. The resulting software will also be stable and secure. This process allows for the production of the complex code that drives our world.

My work in the Computer Science program has allowed me to demonstrate my ability to perform these tasks. I have pulled examples from my past work and the capstone for the program to demonstrate these abilities.

For the area of collaborating in a team environment I have learned that teamwork is crucial. The collaborative effort allows for many benefits. First, I can gain valuable insight by asking another developer to review my code. A fresh set of unbiased eyes can often see things I as the author would miss. It also allows for the brainstorming of ideas. This can lead to multiple approaches for how to develop a given piece of software and the best can be chosen.

I have 3 examples that highlight my ability to collaborate with a team. The first is from a security course, CS-305. I was tasked with performing a code review and providing a plan for correcting the issues I found. My analysis and recommendations:

![CS-305 Code Review](/docs/assets/images/CS305_CodeReview.jpg)

This example showcases my ability to use within a team environment demonstrating my usage of strategies to build a collaborative environment to support organizational decision making. This review allowed the developer to upgrade the code to make the project stable and secure. My next example comes from the capstone course CS-499 and is from the Project 2: Data Structures and Algorithms. This example comes from the Project_Main class:

![Comment.jpg](/docs/assets/images/Comment.jpg)

This example highlights my ability to use contextual in code comments that build a collaborative environment. Commenting such as this serves to identify the purpose of the code, the logic behind it, and its usage to make it easier to use, maintain, and upgrade. My last example is from course CS-310, collaboration and team projects. In this example I was tasked with performing a code review prior to the code being committed on Bitbucket: 

![Bitbucket comment for comit](/docs/assets/images/Comment.png)

This example demonstrates my ability to communicate a code review through a collaborative environment showing I can use professional quality communication. Collectively, these examples demonstrate my ability to work collaboratively as a member of a team to develop stable and secure software solutions.

When it comes to communicating with stakeholders, providing clear and concise information they can understand is important. Flow charts, diagrams, and mock-ups are one tool to aid communication with stakeholders. They allow for the communication of the operation of the program in a visual sense, allowing stakeholders to understand how the program will operate and appear. Equally important is the ability to listen and understand what the stakeholders are saying, communication is a two-way operation. Asking follow up questions to ensure that understanding has been achieved is vital. To develop software that brings value, these communications are important. 

I have 2 examples. The first example comes from course CS-210, a course in programming languages. This example is a flow chart for a program to control a coffee maker, used to ensure that the program design will capture all the requirements set forth:

![Coffee flow chart](/docs/assets/images/Coffee_Maker_Draft_Final.png)

This example shows my ability to create, develop, and deliver professional quality communication. This ensures the required functionality is delivered before any programing begins. My next example is from CS-360, mobile architecture and programming. This example shows a mock up of a screen design for a news aggregate app:

![Mobile App Mock-up](/docs/assets/images/Mobil_Mock_Up.jpg)

This example highlights my ability to communicate appropriately with specific audiences. Together the two above examples demonstrate I can effectively and concisely communicate my ideas.

Data structures and algorithms are the bones and muscles of programs. Data structures are just that, structures that hold data of some type. These can be simple lists that hold integer values to complex binary search trees that hold objects containing multiple values. And there is a lot of choice in between: vectors, multi-dimensional vectors, arrays, and linked lists to name a few. They can all hold data such as simple string or integers to object with multiple data values. Algorithms are the step-by-step process that is used to accomplish a task. When creating algorithms, they should be simple; they should be clearly written and easily understood; they should provide a unique solution to the problem; they should handle unexpected situations and inputs; and they should have a finite number of steps to reach their solution. 

Software engineering is the process of designing, developing, and releasing stable and secure software that provides value and fills a need. A software engineer will use a process that ensures these goals are met, a coder will simply write code. Engineering the software allows for proper documentation to be made; the code to be easily maintained and upgraded; and ensures that the code fills a need the client, users, and stakeholders have. 

 I have two examples that demonstrate my ability to engineer software that allows for stable and secure code to be developed that fills a need. This example comes from the IT-145 course, Foundation in Application Development. This example comes from a project where I was tasked with developing an application for a zoo that required a user name and password and upon verification would output jobs for the individual based on their job level. As part of the process, I developed this pseudocode:
 
 ![Psuedocode image](/docs/assets/images/Pseudocode.jpg)
 
 This pseudocode led to the creation of an application with two classes: UserID and ZooSystemMain. The UserID was responsible for authenticating and verifying the user. ZooSystemMain took the information from UserID and would output the information for the user based on their job level. This example highlights my ability to use pseudocode in the design of software, using it to evaluate computing solutions while managing the trade-offs. My second example is taken from CS-250, Software Development Lifecycle. This example shows where I have taken a user story and developed a test case to use for test driven development. This allows the developer to create code which will meet the requirement of the user story. The user story:
 
 ![User story image](/docs/assets/images/UserStories.jpg)
 
 The test case developed:
 
 ![Test Case image](/docs/assets/images/TestCase.jpg)
 
 This example shows my ability to take information from stakeholders and use it in the design of the software. Showing my ability to use iterative testing techniques in developing code and demonstrating my ability to use well-founded and innovative techniques that deliver value to develop software. These skills are vital to the creation of modern software.
 
 Databases are used for easy storage, retrieval, and editing of data. Databases primarily exist on disk, though some can reside partially or wholly in memory. The use of databases allows programmers a means of long-term data storage that is easily accessible. They can then use this data in their software. Databases can either be local to the machine or accessed over a network. This later allows for the use of databases from anywhere with the internet and for multiple client connections. Databases also come in two types: SQL (Structured Query Language), and NoSQL. SQL databases use tables to store the records, and each record has the fields and only the fields in the table. NoSQL databases are a collection of documents with no formal structure as to what fields a record can have. The difference between the two comes down to accessing the records. SQL databases tend to be faster, as each record is required to have all the fields. However, SQL databases can not handle records that have extra fields. NoSQL databases tend to be more flexible; you can put any record into its collection regardless of the fields that record contains. Both types require a unique identifier for each record, usually the ID field. This is what allows them to locate an individual record. 
 
 In the area of Security, I have 2 examples to showcase my abilities. The first example I have is from CS-305, a course on secure coding. This example is a dependency check run with Maven. It shows the number of vulnerabilities found in the dependencies used:
 
 ![Dependency check image](/docs/assets/images/DependencyCheck.jpg)
 
 Using this information, I can then do follow up research to determine if the vulnerabilities found are legitimate or false positives. I can then patch the legitimate vulnerabilities to develop secure code. This example demonstrates my ability to find and eradicate security vulnerabilities, developing software with a security mindset. My second example comes from project 3 of the capstone course CS-499 and shows my ability to validate user input prior to using it. This example is looking for integer input and will reject anything else and display a warning message:
 
 ![Project 3 integer input method](/docs/assets/images/Project3_IntInputB.jpg)
 
 This example demonstrates my ability to develop software with a security mindset by using an approach that ensures data is validated. These two examples demonstrate my ability to design software with a security mindset. This mindset allows me to develop secure and stable software vital for meeting today’s needs.
 
 My first artifact enhancement for the software design and engineering is an enhancement from the CS-320: Software Testing, Automation, and Quality Assurance course. The project I selected was the final project for the course. It was a collection of classes that stored data for what would be a user’s schedular, storing contacts; appointment; and to-do tasks. This project was developed as independent classes for the purpose of testing those classes for functionality. To enhance the project, I will bring the classes together with a user interface and enable the ability to store the data to disk. This will highlight my ability to design and engineer functioning software.
 
 The second artifact I have selected for my capstone project enhancement: data structures and algorithms is the same project from CS-320 as my first artifact. For this enhancement I will change the software from using three different objects to store the data in to a single object. This will allow me to store the data in a 2-dimensional Vector as linked lists. I will also be adding the ability for different users to maintain different lists of data. The project will also incorporate the enhancements from the first artifact, retaining the user interface and ability to save to disk. This artifact will showcase my ability to use different data structures to provide unique solutions and highlight my ability to use algorithmic principles in its design.
 
 For my third artifact I selected the final project from CS-340: Client/Server development. This project uses Python to create a connection to a local MongoDB database and uses Python for a user interface. To enhance this artifact, I will rewrite the project in Java and connect to a remote database. This will demonstrate my ability to code for databases in multiple languages as well as showing the ability to connect to both local and remote databases. 


### 2.Code Review
[Link to Code Review video](https://youtu.be/1YjFPcJO0So)


### 3. Project 1: Software Design and Engineering
The artifact I have selected for this milestone is the final project for CS-320. This project was initially created in February of 2021. It is a collection of three independent modules designed to be integrated into a larger program. Collectively these modules make up the backbone of a planner by keeping track of appointments, to-do tasks, and a list of contacts.

I have included this artifact in my capstone because it demonstrates my ability to engineer complete software that follows algorithmic principles. This project showcases my ability to develop stable and secure software using a modular design that can easily be maintained and updated. The artifact will be improved on the original by bringing the independent modules together with a user interface and will add the ability to save the data to disc.

In completing this project, I was able to meet some course outcomes. I was able to design and evaluate computing solutions that solve a given problem while managing the tradeoffs. I accomplished this with using pseudocode to design the main method that binds the modules together. I was able to use the pseudocode to segment the software to develop three new classes that provide the user interface, ability to save data, and bind the project in a main method. The pseudocode produced for this:

![Project1_Psuedocode](/docs/assets/images/Project1_psuedocode.jpg)

I have also demonstrated the ability to use well-founded techniques, skills, and tools for the purpose of implementing solutions that deliver value. I accomplished this with robust and efficient code that delivers value. Which is shown by the use of error handling try catch blocks on the file access methods to handle exceptions without crashing the program:

![Project 1 try/catch block](/docs/assets/images/Project1_tryCatch.jpg)

During the enhancement of this project, I had a few learning opportunities. First, I learned how hard it is to go back to a language I haven’t used in about a year. This was probably the most frustrating experience during the development of the project. Second, I learned that Stack Overflow (and similar sites) and Java docs are a great resource. When I was struggling these resources provided a direction to move in, though not always the answer. The one challenge that sticks out in my mind had to do with the scanner utility in Java. For some reason it would decide to not wait for input from time to time. I never found a reason for this in all my research, but I was able to solve the problem by placing a loop that only ended when there was input before the scanner. 

#### Enhanced Source Files for Project 1
1. [Project_Main.java](Project1_Main_e.java)
2. [Project_ui.java](Project1_ui_e.java)
3. [Project_FileShare.java](Project1_FileShare_e.java)
4. [Appointment.java](Appointment_e%20.java)
5. [AppointmentService.java](AppointmentService_e.java)
6. [Contact.java](Contact_e.java)
7. [ContactService.java](ContactService_e.java)
8. [Task.java](Task_e.java)
9. [TaskService.java](TaskService_e.java)

#### Original Source Files for Project 1
1. [Appointment.java](Appointment.java)
2. [AppointmentService.java](AppointmentService.java)
3. [Contact.java](Contact.java)
4. [ContactService.java](ContactService.java)
5. [Task.java](Task.java)
6. [TaskService.java](TaskService.java)


### 4. Project 2: Data Structures and Algorithms
The artifact I have submitted for week for is a re-work of the final project submitted for the CS-320 course. This project was a digital planner storing information for appointments, contacts, and a to-do list. The original work was created in February of 2021. This project was also used for my first enhancement, and I have built upon that for this one.

This artifact is included here because it showcases my ability to use different data structures to accomplish the projects goals. It also highlights my ability to create efficient and error free algorithms to perform the task. This artifact shows my ability to develop modular programs, allow for the re-use of components in other programs. This artifact was improved from the original by implementing a two-dimensional vector to hold the linked lists containing the data. It was further enhanced by creating a user-based system that stores different lists for different users.

In the enhancement of this project, I have completed some to the course outcomes. I employed a strategy to build a collaborative environment. I accomplished this through the use of in code comments placed in the file header that describes the purpose of the file and how to use it. These comments allow for other developers to easily implement, update, and maintain the software.

![Project 2 Header Comment](/docs/assets/images/Comment.jpg)

I also demonstrated the ability to use professional-quality communications that are developed for a specific audience. I accomplished this by creating a flow chart to demonstrate the program flow, showing how the program functions. This shows I can communicate appropriately with specific audiences with context.

![Project 2 Flow Chart](/docs/assets/images/Sub2_FlowChart.jpg)

I learned quite a bit working with the data structure involved in this project. I had never used a two-dimensional vector or array before. At first, I thought I might be able to use the different data objects I had originally developed. While this may be possible, I found it easier and more efficient to redesign the data object into one that filled all three rolls. I initially thought about making this a three-dimensional array but decided to use a linked list as the third dimension. This allowed me to re-use more of my original code and I believe it will help keep the memory footprint of the program down. The biggest challenge I had was in the implementation of the linked lists for the different services. I originally was using a single list that I would blank out, however it kept leaking data from one service to the next. I solved this by initializing the two-dimensional vector with three different linked lists when I added a new user. I was also having issues trying to use three different data objects in the data structure. It wanted to keep giving me warnings, so I designed a single data object to fill all three rolls.

#### Enhanced Source Files for Project 2
1. [Project_Main.java](Project2_Main.java)
2. [Node.java](Node.java)
3. [Vector_Map.java](VectorMap.java)
4. [Project_ui.java](Project2_ui.java)
5. [Project_FileShare](Project2_FileShare.java)

#### Original Source Files for Project 2 (The same files as project 1)
1. [Appointment.java](Appointment.java)
2. [AppointmentService.java](AppointmentService.java)
3. [Contact.java](Contact.java)
4. [ContactService.java](ContactService.java)
5. [Task.java](Task.java)
6. [TaskService.java](TaskService.java)


### 5. Project 3: Databases
The artifact I selected for the Database portion of my portfolio is the Python CRUD application I developed for CS-340 for the final project. As the enhancement for this project, I rewrote the program in Java. The reason I chose this project for inclusion in my portfolio is because it highlights my ability to manipulate a database and shows that I can do this in multiple languages. This artifact also shows several skills I have as a developer. It demonstrates my ability to design software in a modular fashion, with each class having its own role. It shows my ability to test user input and handle unexpected input. It highlights my skills designing software that it easy to read, and stable to run.

In completing this project, I accomplished some of the course outcomes. I was able to use a security mindset that anticipates adversarial exploits. I accomplished this by ensuring that user data is validated before using it. This was done by verifying user input before using it as data. For integer input I accepted a string as input, checked that it contained nothing but integers and then use the input. If this input isn’t integers, it will output a warning message.

![Integer Input Method](/docs/assets/images/Project3_IntInputB.jpg)

I also demonstrate the ability to use well-founded techniques, skills, and tools to implement computer solutions that deliver value. I was able to accomplish this by creating robust and efficient code that delivers value. This is shown in how I use try/catch blocks when accessing the database to handle any exception that may occur during the connection.

![Project3 Try/Catch block](/docs/assets/images/Project3_tryCatch.jpg)

The process of rewriting this software was full of learning experiences. I first needed to learn how the mongo driver for Java functioned, in order to make calls to the database. The hardest part of this for me was any operation that performed writes. This part took several days of pouring through documentation and searching Stack Overflow for similar issues. I then had to learn the logging system the driver used. This was something I wasn’t prepared for, however without implementing this system the driver would issue warnings. This system was something I had never used or researched. To overcome this, I spent a fair amount of time reading the documentation to get this properly set up and configured. This was further hindered by the fact that the logging system uses two separate pieces of software to perform its task. In the end, all the issues I encountered were solved with proper research of both the documentation and similar problems others have encountered. 

#### Enhanced Source Files for Project 3
1. [Project_main.java](Project_Main.java)
2. [Rental.java](Rental.java)
3. [IO_System.java](IO_System.java)
4. [Search_Handler.java](Search_Handler.java)
5. [CollectionEdit_Handlers.java](CollectionEdit_Handlers.java)

#### Original Source Files for Project 3
1. [Mongo_db_Interface.py](Mongo_db_Interface.py)
2. [ProjectTwoDashboard.ipynb](ProjectTwoDashboard.ipynb.txt)
